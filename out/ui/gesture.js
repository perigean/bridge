// Copyright Charles Dueck 2020
// Touch handling
// * detect if a touch is a tap or a pan
//   * taps don't move more than 16 pixels
//   * TODO maybe: taps are faster than x00ms, TODO: instrument and find out what feels OK
// * process taps
//   * first touch starts active tap
//   * all subsequent touches added to tap
//   * tap active until first touch end
//   * tap fires when on last touch end (or touch converted to pan), unless no taps remain (all converted to pan)
//   * new active tap can start while old one is running but nolonger active
// * all pans get put into a single pan tracker
import { pointDistance, pointEquals } from "../point.js";
import { TouchDemux } from "./touch.js";
;
export class Gesture {
    constructor(element, handler) {
        this.handler = handler;
        this.addTap = null;
        this.taps = new Map();
        this.pan = new Map();
        this.nextPanId = 0;
        this.demux = new TouchDemux(element, this);
    }
    endTap(tap, id, panning) {
        this.taps.delete(id);
        tap.active.delete(id);
        if (panning) {
            // If this tap is being converted to a pan because it moved,
            // remove it from the positions list, so it doesn't get sent
            // to the handler once all fingers are up.
            tap.positions.delete(id);
        }
        if (this.addTap === tap) {
            this.addTap = null;
        }
        if (tap.active.size === 0 && tap.positions.size > 0) {
            const positions = [];
            for (const p of tap.positions.values()) {
                positions.push(p.start);
            }
            this.handler.tap(positions);
        }
    }
    start(t) {
        if (this.taps.has(t.identifier)) {
            throw new Error("Touch start on already tracked tap");
        }
        if (this.addTap === null) {
            // If no taps are active, set up a tap to add a touch to.
            this.addTap = {
                active: new Set(),
                positions: new Map(),
            };
        }
        this.addTap.active.add(t.identifier);
        const pos = [t.clientX, t.clientY];
        this.addTap.positions.set(t.identifier, {
            curr: pos,
            start: pos,
        });
        this.taps.set(t.identifier, this.addTap);
    }
    move(ts) {
        let panMoved = false;
        for (const t of ts) {
            const tap = this.taps.get(t.identifier);
            if (tap !== undefined) {
                const pos = tap.positions.get(t.identifier);
                if (pos === undefined) {
                    throw new Error("Touch in taps, but not positions");
                }
                pos.curr = [t.clientX, t.clientY];
                if (16 <= pointDistance(pos.curr, pos.start)) {
                    // Tap has moved enough to be a pan instead.
                    this.endTap(tap, t.identifier, true);
                    this.pan.set(t.identifier, {
                        id: this.nextPanId++,
                        curr: pos.curr,
                        prev: pos.start,
                        start: pos.start,
                    });
                    panMoved = true;
                }
            }
            else {
                const pos = this.pan.get(t.identifier);
                if (pos === undefined) {
                    throw new Error("Touch not in taps or pans");
                }
                pos.prev = pos.curr;
                pos.curr = [t.clientX, t.clientY];
                if (!pointEquals(pos.prev, pos.curr)) {
                    panMoved = true;
                }
            }
        }
        if (panMoved) {
            const positions = [];
            // NB: pan is in insertion order, so positions will be sent from oldest touch to newest.
            for (const p of this.pan.values()) {
                positions.push(p);
            }
            this.handler.pan(positions);
        }
    }
    end(id) {
        const tap = this.taps.get(id);
        if (tap !== undefined) {
            this.endTap(tap, id, false);
            return;
        }
        const pan = this.pan.get(id);
        if (pan !== undefined) {
            this.handler.panTouchEnd(pan.id);
            this.pan.delete(id);
            return;
        }
        throw new Error("Touch end that was not a tap or a pan");
    }
    disconnect() {
        this.demux.disconnect();
    }
}
;
// TODO: better separation between IDs on touch events, and the internal IDs passed to handler.
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ2VzdHVyZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy91aS9nZXN0dXJlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLCtCQUErQjtBQUUvQixpQkFBaUI7QUFDakIsd0NBQXdDO0FBQ3hDLDBDQUEwQztBQUMxQywwRkFBMEY7QUFDMUYsaUJBQWlCO0FBQ2pCLG9DQUFvQztBQUNwQywwQ0FBMEM7QUFDMUMsdUNBQXVDO0FBQ3ZDLGlIQUFpSDtBQUNqSCw0RUFBNEU7QUFDNUUsK0NBQStDO0FBRS9DLE9BQU8sRUFBVyxhQUFhLEVBQUUsV0FBVyxFQUFFLE1BQU0sYUFBYSxDQUFBO0FBQ2pFLE9BQU8sRUFBRSxVQUFVLEVBQWdCLE1BQU0sWUFBWSxDQUFBO0FBaUJwRCxDQUFDO0FBWUYsTUFBTSxPQUFPLE9BQU87SUE2QmhCLFlBQVksT0FBb0IsRUFBRSxPQUF1QjtRQUNyRCxJQUFJLENBQUMsT0FBTyxHQUFHLE9BQU8sQ0FBQztRQUN2QixJQUFJLENBQUMsTUFBTSxHQUFHLElBQUksQ0FBQztRQUNuQixJQUFJLENBQUMsSUFBSSxHQUFHLElBQUksR0FBRyxFQUFFLENBQUM7UUFDdEIsSUFBSSxDQUFDLEdBQUcsR0FBRyxJQUFJLEdBQUcsRUFBRSxDQUFDO1FBQ3JCLElBQUksQ0FBQyxTQUFTLEdBQUcsQ0FBQyxDQUFDO1FBQ25CLElBQUksQ0FBQyxLQUFLLEdBQUcsSUFBSSxVQUFVLENBQUMsT0FBTyxFQUFFLElBQUksQ0FBQyxDQUFDO0lBQy9DLENBQUM7SUE1Qk8sTUFBTSxDQUFDLEdBQWMsRUFBRSxFQUFVLEVBQUUsT0FBZ0I7UUFDdkQsSUFBSSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLENBQUM7UUFDckIsR0FBRyxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLENBQUM7UUFDdEIsSUFBSSxPQUFPLEVBQUU7WUFDVCw0REFBNEQ7WUFDNUQsNERBQTREO1lBQzVELDBDQUEwQztZ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QUFNLENBQUMsR0FBRyxFQUFFLEVBQUUsRUFBRSxLQUFLLENBQUMsQ0FBQztZQUM1QixPQUFPO1NBQ1Y7UUFDRCxNQUFNLEdBQUcsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsQ0FBQztRQUM3QixJQUFJLEdBQUcsS0FBSyxTQUFTLEVBQUU7WUFDbkIsSUFBSSxDQUFDLE9BQU8sQ0FBQyxXQUFXLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxDQUFDO1lBQ2pDLElBQUksQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxDQUFDO1lBQ3BCLE9BQU87U0FDVjtRQUNELE1BQU0sSUFBSSxLQUFLLENBQUMsdUNBQXVDLENBQUMsQ0FBQztJQUM3RCxDQUFDO0lBQ0QsVUFBVTtRQUNOLElBQUksQ0FBQyxLQUFLLENBQUMsVUFBVSxFQUFFLENBQUM7SUFDNUIsQ0FBQztDQUNKO0FBQUEsQ0FBQztBQUVGLCtGQUErRiIsInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCBDaGFybGVzIER1ZWNrIDIwMjBcblxuLy8gVG91Y2ggaGFuZGxpbmdcbi8vICogZGV0ZWN0IGlmIGEgdG91Y2ggaXMgYSB0YXAgb3IgYSBwYW5cbi8vICAgKiB0YXBzIGRvbid0IG1vdmUgbW9yZSB0aGFuIDE2IHBpeGVsc1xuLy8gICAqIFRPRE8gbWF5YmU6IHRhcHMgYXJlIGZhc3RlciB0aGFuIHgwMG1zLCBUT0RPOiBpbnN0cnVtZW50IGFuZCBmaW5kIG91dCB3aGF0IGZlZWxzIE9LXG4vLyAqIHByb2Nlc3MgdGFwc1xuLy8gICAqIGZpcnN0IHRvdWNoIHN0YXJ0cyBhY3RpdmUgdGFwXG4vLyAgICogYWxsIHN1YnNlcXVlbnQgdG91Y2hlcyBhZGRlZCB0byB0YXBcbi8vICAgKiB0YXAgYWN0aXZlIHVudGlsIGZpcnN0IHRvdWNoIGVuZFxuLy8gICAqIHRhcCBmaXJlcyB3aGVuIG9uIGxhc3QgdG91Y2ggZW5kIChvciB0b3VjaCBjb252ZXJ0ZWQgdG8gcGFuKSwgdW5sZXNzIG5vIHRhcHMgcmVtYWluIChhbGwgY29udmVydGVkIHRvIHBhbilcbi8vICAgKiBuZXcgYWN0aXZlIHRhcCBjYW4gc3RhcnQgd2hpbGUgb2xkIG9uZSBpcyBydW5uaW5nIGJ1dCBub2xvbmdlciBhY3RpdmVcbi8vICogYWxsIHBhbnMgZ2V0IHB1dCBpbnRvIGEgc2luZ2xlIHBhbiB0cmFja2VyXG5cbmltcG9ydCB7IFBvaW50MkQsIHBvaW50RGlzdGFuY2UsIHBvaW50RXF1YWxzIH0gZnJvbSBcIi4uL3BvaW50LmpzXCJcbmltcG9ydCB7IFRvdWNoRGVtdXgsIFRvdWNoSGFuZGxlciB9IGZyb20gXCIuL3RvdWNoLmpzXCJcblxuZXhwb3J0IHR5cGUgVGFwID0gQXJyYXk8UG9pbnQyRD47XG5cbmV4cG9ydCB0eXBlIFBhblRvdWNoID0ge1xuICAgIGlkOiBudW1iZXI7XG4gICAgc3RhcnQ6IFBvaW50MkQ7XG4gICAgcHJldjogUG9pbnQyRDtcbiAgICBjdXJyOiBQb2ludDJEO1xufTtcblxuZXhwb3J0IHR5cGUgUGFuID0gQXJyYXk8UGFuVG91Y2g+O1xuXG5leHBvcnQgaW50ZXJmYWNlIEdlc3R1cmVIYW5kbGVyIHtcbiAgICB0YXA6ICh0OiBUYXApID0+IHZvaWQ7XG4gICAgcGFuOiAocDogUGFuKSA9PiB2b2lkO1xuICAgIHBhblRvdWNoRW5kOiAoaWQ6IG51bWJlcikgPT4gdm9pZDtcbn07XG5cbnR5cGUgQWN0aXZlVGFwID0ge1xuICAgIGFjdGl2ZTogU2V0PG51bWJlcj47XG4gICAgcG9zaXRpb25zOiBNYXA8bnVtYmVyLCB7XG4gICAgICAgIGN1cnI6IFBvaW50MkQsXG4gICAgICAgIHN0YXJ0OiBQb2ludDJELFxuICAgIH0+O1xufTtcblxudHlwZSBBY3RpdmVQYW4gPSBNYXA8bnVtYmVyLCBQYW5Ub3VjaD47XG5cbmV4cG9ydCBjbGFzcyBHZXN0dXJlIGltcGxlbWVudHMgVG91Y2hIYW5kbGVyIHtcbiAgICBwcml2YXRlIGRlbXV4OiBUb3VjaERlbXV4O1xuICAgIHByaXZhdGUgaGFuZGxlcjogR2VzdHVyZUhhbmRsZXI7XG4gICAgcHJpdmF0ZSBhZGRUYXA6IEFjdGl2ZVRhcCB8IG51bGw7XG4gICAgcHJpdmF0ZSB0YXBzOiBNYXA8bnVtYmVyLCBBY3RpdmVUYXA+O1xuICAgIHByaXZhdGUgcGFuOiBBY3RpdmVQYW47XG4gICAgcHJpdmF0ZSBuZXh0UGFuSWQ6IG51bWJlcjtcblxuICAgIHByaXZhdGUgZW5kVGFwKHRhcDogQWN0aXZlVGFwLCBpZDogbnVtYmVyLCBwYW5uaW5nOiBib29sZWFuKSB7XG4gICAgICAgIHRoaXMudGFwcy5kZWxldGUoaWQpO1xuICAgICAgICB0YXAuYWN0aXZlLmRlbGV0ZShpZCk7XG4gICAgICAgIGlmIChwYW5uaW5nKSB7XG4gICAgICAgICAgICAvLyBJZiB0aGlzIHRhcCBpcyBiZWluZyBjb252ZXJ0ZWQgdG8gYSBwYW4gYmVjYXVzZSBpdCBtb3ZlZCxcbiAgICAgICAgICAgIC8vIHJlbW92ZSBpdCBmcm9tIHRoZSBwb3NpdGlvbnMgbGlzdCwgc28gaXQgZG9lc24ndCBnZXQgc2VudFxuICAgICAgICAgICAgLy8gdG8gdGhlIGhhbmRsZXIgb25jZSBhbGwgZmluZ2VycyBhcmUgdXAuXG4gICAgICAgICAgICB0YXAucG9zaXRpb25zLmRlbGV0ZShpZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuYWRkVGFwID09PSB0YXApIHtcbiAgICAgICAgICAgIHRoaXMuYWRkVGFwID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGFwLmFjdGl2ZS5zaXplID09PSAwICYmIHRhcC5wb3NpdGlvbnMuc2l6ZSA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IHBvc2l0aW9ucyA9IFtdO1xuICAgICAgICAgICAgZm9yIChjb25zdCBwIG9mIHRhcC5wb3NpdGlvbnMudmFsdWVzKCkpIHtcbiAgICAgICAgICAgICAgICBwb3NpdGlvbnMucHVzaChwLnN0YXJ0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuaGFuZGxlci50YXAocG9zaXRpb25zKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0cnVjdG9yKGVsZW1lbnQ6IEhUTUxFbGVtZW50LCBoYW5kbGVyOiBHZXN0dXJlSGFuZGxlcikge1xuICAgICAgICB0aGlzLmhhbmRsZXIgPSBoYW5kbGVyO1xuICAgICAgICB0aGlzLmFkZFRhcCA9IG51bGw7XG4gICAgICAgIHRoaXMudGFwcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5wYW4gPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMubmV4dFBhbklkID0gMDtcbiAgICAgICAgdGhpcy5kZW11eCA9IG5ldyBUb3VjaERlbXV4KGVsZW1lbnQsIHRoaXMpO1xuICAgIH1cblxuICAgIHN0YXJ0KHQ6IFRvdWNoKSB7XG4gICAgICAgIGlmICh0aGlzLnRhcHMuaGFzKHQuaWRlbnRpZmllcikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRvdWNoIHN0YXJ0IG9uIGFscmVhZHkgdHJhY2tlZCB0YXBcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuYWRkVGFwID09PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBJZiBubyB0YXBzIGFyZSBhY3RpdmUsIHNldCB1cCBhIHRhcCB0byBhZGQgYSB0b3VjaCB0by5cbiAgICAgICAgICAgIHRoaXMuYWRkVGFwID0ge1xuICAgICAgICAgICAgICAgIGFjdGl2ZTogbmV3IFNldCgpLFxuICAgICAgICAgICAgICAgIHBvc2l0aW9uczogbmV3IE1hcCgpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFkZFRhcC5hY3RpdmUuYWRkKHQuaWRlbnRpZmllcik7XG4gICAgICAgIGNvbnN0IHBvczogUG9pbnQyRCA9IFt0LmNsaWVudFgsIHQuY2xpZW50WV07XG4gICAgICAgIHRoaXMuYWRkVGFwLnBvc2l0aW9ucy5zZXQodC5pZGVudGlmaWVyLCB7XG4gICAgICAgICAgICBjdXJyOiBwb3MsXG4gICAgICAgICAgICBzdGFydDogcG9zLFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy50YXBzLnNldCh0LmlkZW50aWZpZXIsIHRoaXMuYWRkVGFwKTtcbiAgICB9XG5cbiAgICBtb3ZlKHRzOiBUb3VjaExpc3QpIHtcbiAgICAgICAgbGV0IHBhbk1vdmVkID0gZmFsc2U7XG4gICAgICAgIGZvciAoY29uc3QgdCBvZiB0cykge1xuICAgICAgICAgICAgY29uc3QgdGFwID0gdGhpcy50YXBzLmdldCh0LmlkZW50aWZpZXIpO1xuICAgICAgICAgICAgaWYgKHRhcCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcG9zID0gdGFwLnBvc2l0aW9ucy5nZXQodC5pZGVudGlmaWVyKTtcbiAgICAgICAgICAgICAgICBpZiAocG9zID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVG91Y2ggaW4gdGFwcywgYnV0IG5vdCBwb3NpdGlvbnNcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHBvcy5jdXJyID0gW3QuY2xpZW50WCwgdC5jbGllbnRZXTtcbiAgICAgICAgICAgICAgICBpZiAoMTYgPD0gcG9pbnREaXN0YW5jZShwb3MuY3VyciwgcG9zLnN0YXJ0KSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBUYXAgaGFzIG1vdmVkIGVub3VnaCB0byBiZSBhIHBhbiBpbnN0ZWFkLlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmVuZFRhcCh0YXAsIHQuaWRlbnRpZmllciwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGFuLnNldCh0LmlkZW50aWZpZXIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkOiB0aGlzLm5leHRQYW5JZCsrLFxuICAgICAgICAgICAgICAgICAgICAgICAgY3VycjogcG9zLmN1cnIsXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmV2OiBwb3Muc3RhcnQsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydDogcG9zLnN0YXJ0LFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgcGFuTW92ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcG9zID0gdGhpcy5wYW4uZ2V0KHQuaWRlbnRpZmllcik7XG4gICAgICAgICAgICAgICAgaWYgKHBvcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRvdWNoIG5vdCBpbiB0YXBzIG9yIHBhbnNcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHBvcy5wcmV2ID0gcG9zLmN1cnI7XG4gICAgICAgICAgICAgICAgcG9zLmN1cnIgPSBbdC5jbGllbnRYLCB0LmNsaWVudFldO1xuICAgICAgICAgICAgICAgIGlmICghcG9pbnRFcXVhbHMocG9zLnByZXYsIHBvcy5jdXJyKSkge1xuICAgICAgICAgICAgICAgICAgICBwYW5Nb3ZlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChwYW5Nb3ZlZCkge1xuICAgICAgICAgICAgY29uc3QgcG9zaXRpb25zID0gW107XG4gICAgICAgICAgICAvLyBOQjogcGFuIGlzIGluIGluc2VydGlvbiBvcmRlciwgc28gcG9zaXRpb25zIHdpbGwgYmUgc2VudCBmcm9tIG9sZGVzdCB0b3VjaCB0byBuZXdlc3QuXG4gICAgICAgICAgICBmb3IgKGNvbnN0IHAgb2YgdGhpcy5wYW4udmFsdWVzKCkpIHtcbiAgICAgICAgICAgICAgICBwb3NpdGlvbnMucHVzaChwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuaGFuZGxlci5wYW4ocG9zaXRpb25zKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGVuZChpZDogbnVtYmVyKSB7XG4gICAgICAgIGNvbnN0IHRhcCA9IHRoaXMudGFwcy5nZXQoaWQpO1xuICAgICAgICBpZiAodGFwICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZW5kVGFwKHRhcCwgaWQsIGZhbHNlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYW4gPSB0aGlzLnBhbi5nZXQoaWQpO1xuICAgICAgICBpZiAocGFuICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlci5wYW5Ub3VjaEVuZChwYW4uaWQpO1xuICAgICAgICAgICAgdGhpcy5wYW4uZGVsZXRlKGlkKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUb3VjaCBlbmQgdGhhdCB3YXMgbm90IGEgdGFwIG9yIGEgcGFuXCIpO1xuICAgIH1cbiAgICBkaXNjb25uZWN0KCkge1xuICAgICAgICB0aGlzLmRlbXV4LmRpc2Nvbm5lY3QoKTtcbiAgICB9XG59O1xuXG4vLyBUT0RPOiBiZXR0ZXIgc2VwYXJhdGlvbiBiZXR3ZWVuIElEcyBvbiB0b3VjaCBldmVudHMsIGFuZCB0aGUgaW50ZXJuYWwgSURzIHBhc3NlZCB0byBoYW5kbGVyLiJdfQ==