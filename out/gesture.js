// Copyright Charles Dueck 2020
// Touch handling
// * detect if a touch is a tap or a pan
//   * taps don't move more than 16 pixels
//   * TODO maybe: taps are faster than x00ms, TODO: instrument and find out what feels OK
// * process taps
//   * first touch starts active tap
//   * all subsequent touches added to tap
//   * tap active until first touch end
//   * tap fires when on last touch end (or touch converted to pan), unless no taps remain (all converted to pan)
//   * new active tap can start while old one is running but nolonger active
// * all pans get put into a single pan tracker
import { pointDistance, pointEquals } from "./point.js";
;
export class Gestures {
    constructor() {
        this.handlers = [];
        this.addTap = null;
        this.taps = new Map();
        this.pan = new Map();
    }
    addGestureHandler(handler) {
        this.handlers.push(handler);
    }
    removeGestureHandler(handler) {
        this.handlers = this.handlers.filter(h => h != handler);
    }
    endTap(tap, id, panning) {
        this.taps.delete(id);
        tap.active.delete(id);
        if (panning) {
            tap.positions.delete(id);
        }
        if (this.addTap === tap) {
            this.addTap = null;
        }
        if (tap.active.size === 0 && tap.positions.size > 0) {
            const positions = [];
            for (const p of tap.positions.values()) {
                positions.push(p.start);
            }
            for (const h of this.handlers) {
                h.tap(positions);
            }
        }
    }
    start(t) {
        if (this.taps.has(t.identifier)) {
            throw new Error("Touch start on already tracked tap");
        }
        if (this.addTap === null) {
            // If no taps are active, set up a tap to add a touch to.
            this.addTap = {
                active: new Set(),
                positions: new Map(),
            };
        }
        this.addTap.active.add(t.identifier);
        const pos = [t.clientX, t.clientY];
        this.addTap.positions.set(t.identifier, {
            curr: pos,
            start: pos,
        });
        this.taps.set(t.identifier, this.addTap);
    }
    move(ts) {
        let panMoved = false;
        for (const t of ts) {
            const tap = this.taps.get(t.identifier);
            if (tap !== undefined) {
                const pos = tap.positions.get(t.identifier);
                if (pos === undefined) {
                    throw new Error("Touch in taps, but not positions");
                }
                pos.curr = [t.clientX, t.clientY];
                if (16 <= pointDistance(pos.curr, pos.start)) {
                    // Tap has moved enough to be a pan instead.
                    this.endTap(tap, t.identifier, true);
                    this.pan.set(t.identifier, {
                        curr: pos.curr,
                        prev: pos.start,
                        start: pos.start,
                    });
                    panMoved = true;
                }
            }
            else {
                const pos = this.pan.get(t.identifier);
                if (pos === undefined) {
                    throw new Error("Touch not in taps or pans");
                }
                pos.prev = pos.curr;
                pos.curr = [t.clientX, t.clientY];
                if (!pointEquals(pos.prev, pos.curr)) {
                    panMoved = true;
                }
            }
        }
        if (panMoved) {
            const positions = [];
            // NB: pan is in insertion order, so positions will be sent from oldest touch to newest.
            for (const p of this.pan.values()) {
                positions.push(p);
            }
            for (const h of this.handlers) {
                h.pan(positions);
            }
        }
    }
    end(id) {
        const tap = this.taps.get(id);
        if (tap !== undefined) {
            this.endTap(tap, id, false);
        }
        else if (!this.pan.delete(id)) {
            throw new Error("Touch end that was not a tap or a pan");
        }
    }
}
;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ2VzdHVyZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uL3NyYy9nZXN0dXJlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLCtCQUErQjtBQUUvQixpQkFBaUI7QUFDakIsd0NBQXdDO0FBQ3hDLDBDQUEwQztBQUMxQywwRkFBMEY7QUFDMUYsaUJBQWlCO0FBQ2pCLG9DQUFvQztBQUNwQywwQ0FBMEM7QUFDMUMsdUNBQXVDO0FBQ3ZDLGlIQUFpSDtBQUNqSCw0RUFBNEU7QUFDNUUsK0NBQStDO0FBRS9DLE9BQU8sRUFBVyxhQUFhLEVBQUUsV0FBVyxFQUFFLE1BQU0sWUFBWSxDQUFBO0FBYy9ELENBQUM7QUFnQkYsTUFBTSxPQUFPLFFBQVE7SUFrQ2pCO1FBQ0ksSUFBSSxDQUFDLFFBQVEsR0FBRyxFQUFFLENBQUM7UUFDbkIsSUFBSSxDQUFDLE1BQU0sR0FBRyxJQUFJLENBQUM7UUFDbkIsSUFBSSxDQUFDLElBQUksR0FBRyxJQUFJLEdBQUcsRUFBRSxDQUFDO1FBQ3RCLElBQUksQ0FBQyxHQUFHLEdBQUcsSUFBSSxHQUFHLEVBQUUsQ0FBQztJQUN6QixDQUFDO0lBakNELGlCQUFpQixDQUFDLE9BQXVCO1FBQ3JDLElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDO0lBQ2hDLENBQUM7SUFFRCxvQkFBb0IsQ0FBQyxPQUF1QjtRQUN4QyxJQUFJLENBQUMsUUFBUSxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxJQUFJLE9BQU8sQ0FBQyxDQUFDO0lBQzVELENBQUM7SUFFTyxNQUFNLENBQUMsR0FBYyxFQUFFLEVBQVUsRUFBRSxPQUFnQjtRQUN2RCxJQUFJLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsQ0FBQztRQUNyQixHQUFHLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsQ0FBQztRQUN0QixJQUFJLE9B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QyxDQUFDO1FBQzlCLElBQUksR0FBRyxLQUFLLFNBQVMsRUFBRTtZQUNuQixJQUFJLENBQUMsTUFBTSxDQUFDLEdBQUcsRUFBRSxFQUFFLEVBQUUsS0FBSyxDQUFDLENBQUM7U0FDL0I7YUFBTSxJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLEVBQUU7WUFDN0IsTUFBTSxJQUFJLEtBQUssQ0FBQyx1Q0FBdUMsQ0FBQyxDQUFDO1NBQzVEO0lBQ0wsQ0FBQztDQUNKO0FBQUEsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCBDaGFybGVzIER1ZWNrIDIwMjBcblxuLy8gVG91Y2ggaGFuZGxpbmdcbi8vICogZGV0ZWN0IGlmIGEgdG91Y2ggaXMgYSB0YXAgb3IgYSBwYW5cbi8vICAgKiB0YXBzIGRvbid0IG1vdmUgbW9yZSB0aGFuIDE2IHBpeGVsc1xuLy8gICAqIFRPRE8gbWF5YmU6IHRhcHMgYXJlIGZhc3RlciB0aGFuIHgwMG1zLCBUT0RPOiBpbnN0cnVtZW50IGFuZCBmaW5kIG91dCB3aGF0IGZlZWxzIE9LXG4vLyAqIHByb2Nlc3MgdGFwc1xuLy8gICAqIGZpcnN0IHRvdWNoIHN0YXJ0cyBhY3RpdmUgdGFwXG4vLyAgICogYWxsIHN1YnNlcXVlbnQgdG91Y2hlcyBhZGRlZCB0byB0YXBcbi8vICAgKiB0YXAgYWN0aXZlIHVudGlsIGZpcnN0IHRvdWNoIGVuZFxuLy8gICAqIHRhcCBmaXJlcyB3aGVuIG9uIGxhc3QgdG91Y2ggZW5kIChvciB0b3VjaCBjb252ZXJ0ZWQgdG8gcGFuKSwgdW5sZXNzIG5vIHRhcHMgcmVtYWluIChhbGwgY29udmVydGVkIHRvIHBhbilcbi8vICAgKiBuZXcgYWN0aXZlIHRhcCBjYW4gc3RhcnQgd2hpbGUgb2xkIG9uZSBpcyBydW5uaW5nIGJ1dCBub2xvbmdlciBhY3RpdmVcbi8vICogYWxsIHBhbnMgZ2V0IHB1dCBpbnRvIGEgc2luZ2xlIHBhbiB0cmFja2VyXG5cbmltcG9ydCB7IFBvaW50MkQsIHBvaW50RGlzdGFuY2UsIHBvaW50RXF1YWxzIH0gZnJvbSBcIi4vcG9pbnQuanNcIlxuaW1wb3J0IHsgVG91Y2hIYW5kbGVyIH0gZnJvbSBcIi4vdG91Y2guanNcIlxuXG5leHBvcnQgdHlwZSBUYXAgPSBBcnJheTxQb2ludDJEPjtcblxuZXhwb3J0IHR5cGUgUGFuID0gQXJyYXk8e1xuICAgIHN0YXJ0OiBQb2ludDJEO1xuICAgIHByZXY6IFBvaW50MkQ7XG4gICAgY3VycjogUG9pbnQyRDtcbn0+O1xuXG5leHBvcnQgaW50ZXJmYWNlIEdlc3R1cmVIYW5kbGVyIHtcbiAgICB0YXA6ICh0OiBUYXApID0+IHZvaWQ7XG4gICAgcGFuOiAocDogUGFuKSA9PiB2b2lkO1xufTtcblxudHlwZSBBY3RpdmVUYXAgPSB7XG4gICAgYWN0aXZlOiBTZXQ8bnVtYmVyPjtcbiAgICBwb3NpdGlvbnM6IE1hcDxudW1iZXIsIHtcbiAgICAgICAgY3VycjogUG9pbnQyRCxcbiAgICAgICAgc3RhcnQ6IFBvaW50MkQsXG4gICAgfT47XG59O1xuXG50eXBlIEFjdGl2ZVBhbiA9IE1hcDxudW1iZXIsIHtcbiAgICBjdXJyOiBQb2ludDJELFxuICAgIHByZXY6IFBvaW50MkQsXG4gICAgc3RhcnQ6IFBvaW50MkQsXG59PjtcblxuZXhwb3J0IGNsYXNzIEdlc3R1cmVzIGltcGxlbWVudHMgVG91Y2hIYW5kbGVyIHtcbiAgICBwcml2YXRlIGhhbmRsZXJzOiBBcnJheTxHZXN0dXJlSGFuZGxlcj47XG4gICAgcHJpdmF0ZSBhZGRUYXA6IEFjdGl2ZVRhcCB8IG51bGw7XG4gICAgcHJpdmF0ZSB0YXBzOiBNYXA8bnVtYmVyLCBBY3RpdmVUYXA+O1xuICAgIHByaXZhdGUgcGFuOiBBY3RpdmVQYW47XG5cbiAgICBhZGRHZXN0dXJlSGFuZGxlcihoYW5kbGVyOiBHZXN0dXJlSGFuZGxlcikge1xuICAgICAgICB0aGlzLmhhbmRsZXJzLnB1c2goaGFuZGxlcik7XG4gICAgfVxuXG4gICAgcmVtb3ZlR2VzdHVyZUhhbmRsZXIoaGFuZGxlcjogR2VzdHVyZUhhbmRsZXIpIHtcbiAgICAgICAgdGhpcy5oYW5kbGVycyA9IHRoaXMuaGFuZGxlcnMuZmlsdGVyKGggPT4gaCAhPSBoYW5kbGVyKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGVuZFRhcCh0YXA6IEFjdGl2ZVRhcCwgaWQ6IG51bWJlciwgcGFubmluZzogYm9vbGVhbikge1xuICAgICAgICB0aGlzLnRhcHMuZGVsZXRlKGlkKTtcbiAgICAgICAgdGFwLmFjdGl2ZS5kZWxldGUoaWQpO1xuICAgICAgICBpZiAocGFubmluZykge1xuICAgICAgICAgICAgdGFwLnBvc2l0aW9ucy5kZWxldGUoaWQpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmFkZFRhcCA9PT0gdGFwKSB7XG4gICAgICAgICAgICB0aGlzLmFkZFRhcCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRhcC5hY3RpdmUuc2l6ZSA9PT0gMCAmJiB0YXAucG9zaXRpb25zLnNpemUgPiAwKSB7XG4gICAgICAgICAgICBjb25zdCBwb3NpdGlvbnMgPSBbXTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgcCBvZiB0YXAucG9zaXRpb25zLnZhbHVlcygpKSB7XG4gICAgICAgICAgICAgICAgcG9zaXRpb25zLnB1c2gocC5zdGFydCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGggb2YgdGhpcy5oYW5kbGVycykge1xuICAgICAgICAgICAgICAgIGgudGFwKHBvc2l0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5oYW5kbGVycyA9IFtdO1xuICAgICAgICB0aGlzLmFkZFRhcCA9IG51bGw7XG4gICAgICAgIHRoaXMudGFwcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5wYW4gPSBuZXcgTWFwKCk7XG4gICAgfVxuXG4gICAgc3RhcnQodDogVG91Y2gpIHtcbiAgICAgICAgaWYgKHRoaXMudGFwcy5oYXModC5pZGVudGlmaWVyKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVG91Y2ggc3RhcnQgb24gYWxyZWFkeSB0cmFja2VkIHRhcFwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5hZGRUYXAgPT09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIElmIG5vIHRhcHMgYXJlIGFjdGl2ZSwgc2V0IHVwIGEgdGFwIHRvIGFkZCBhIHRvdWNoIHRvLlxuICAgICAgICAgICAgdGhpcy5hZGRUYXAgPSB7XG4gICAgICAgICAgICAgICAgYWN0aXZlOiBuZXcgU2V0KCksXG4gICAgICAgICAgICAgICAgcG9zaXRpb25zOiBuZXcgTWFwKCksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYWRkVGFwLmFjdGl2ZS5hZGQodC5pZGVudGlmaWVyKTtcbiAgICAgICAgY29uc3QgcG9zOiBQb2ludDJEID0gW3QuY2xpZW50WCwgdC5jbGllbnRZXTtcbiAgICAgICAgdGhpcy5hZGRUYXAucG9zaXRpb25zLnNldCh0LmlkZW50aWZpZXIsIHtcbiAgICAgICAgICAgIGN1cnI6IHBvcyxcbiAgICAgICAgICAgIHN0YXJ0OiBwb3MsXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnRhcHMuc2V0KHQuaWRlbnRpZmllciwgdGhpcy5hZGRUYXApO1xuICAgIH1cblxuICAgIG1vdmUodHM6IFRvdWNoTGlzdCkge1xuICAgICAgICBsZXQgcGFuTW92ZWQgPSBmYWxzZTtcbiAgICAgICAgZm9yIChjb25zdCB0IG9mIHRzKSB7XG4gICAgICAgICAgICBjb25zdCB0YXAgPSB0aGlzLnRhcHMuZ2V0KHQuaWRlbnRpZmllcik7XG4gICAgICAgICAgICBpZiAodGFwICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwb3MgPSB0YXAucG9zaXRpb25zLmdldCh0LmlkZW50aWZpZXIpO1xuICAgICAgICAgICAgICAgIGlmIChwb3MgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUb3VjaCBpbiB0YXBzLCBidXQgbm90IHBvc2l0aW9uc1wiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcG9zLmN1cnIgPSBbdC5jbGllbnRYLCB0LmNsaWVudFldO1xuICAgICAgICAgICAgICAgIGlmICgxNiA8PSBwb2ludERpc3RhbmNlKHBvcy5jdXJyLCBwb3Muc3RhcnQpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRhcCBoYXMgbW92ZWQgZW5vdWdoIHRvIGJlIGEgcGFuIGluc3RlYWQuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW5kVGFwKHRhcCwgdC5pZGVudGlmaWVyLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wYW4uc2V0KHQuaWRlbnRpZmllciwge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycjogcG9zLmN1cnIsXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmV2OiBwb3Muc3RhcnQsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydDogcG9zLnN0YXJ0LFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgcGFuTW92ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcG9zID0gdGhpcy5wYW4uZ2V0KHQuaWRlbnRpZmllcik7XG4gICAgICAgICAgICAgICAgaWYgKHBvcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRvdWNoIG5vdCBpbiB0YXBzIG9yIHBhbnNcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHBvcy5wcmV2ID0gcG9zLmN1cnI7XG4gICAgICAgICAgICAgICAgcG9zLmN1cnIgPSBbdC5jbGllbnRYLCB0LmNsaWVudFldO1xuICAgICAgICAgICAgICAgIGlmICghcG9pbnRFcXVhbHMocG9zLnByZXYsIHBvcy5jdXJyKSkge1xuICAgICAgICAgICAgICAgICAgICBwYW5Nb3ZlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChwYW5Nb3ZlZCkge1xuICAgICAgICAgICAgY29uc3QgcG9zaXRpb25zID0gW107XG4gICAgICAgICAgICAvLyBOQjogcGFuIGlzIGluIGluc2VydGlvbiBvcmRlciwgc28gcG9zaXRpb25zIHdpbGwgYmUgc2VudCBmcm9tIG9sZGVzdCB0b3VjaCB0byBuZXdlc3QuXG4gICAgICAgICAgICBmb3IgKGNvbnN0IHAgb2YgdGhpcy5wYW4udmFsdWVzKCkpIHtcbiAgICAgICAgICAgICAgICBwb3NpdGlvbnMucHVzaChwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoY29uc3QgaCBvZiB0aGlzLmhhbmRsZXJzKSB7XG4gICAgICAgICAgICAgICAgaC5wYW4ocG9zaXRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGVuZChpZDogbnVtYmVyKSB7XG4gICAgICAgIGNvbnN0IHRhcCA9IHRoaXMudGFwcy5nZXQoaWQpO1xuICAgICAgICBpZiAodGFwICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZW5kVGFwKHRhcCwgaWQsIGZhbHNlKTtcbiAgICAgICAgfSBlbHNlIGlmICghdGhpcy5wYW4uZGVsZXRlKGlkKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVG91Y2ggZW5kIHRoYXQgd2FzIG5vdCBhIHRhcCBvciBhIHBhblwiKTtcbiAgICAgICAgfVxuICAgIH1cbn07Il19