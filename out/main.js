import { Viewport } from "./viewport.js";
import { pointDistance, pointEquals, pointSub, pointAdd, pointAngle } from "./point.js";
import { transformPoint, transformTranslateCreate, transformRotate, transformScale, transformTranslate } from "./transform.js";
const c = document.getElementById("canvas");
if (c === null) {
    throw new Error("No canvas element");
}
const ctx = c.getContext("2d");
if (ctx === null) {
    throw new Error("No 2d context");
}
const vp = new Viewport(ctx, () => {
    ctx.fillStyle = "black";
    ctx.fillRect(-16, -16, 15, 15);
    ctx.fillRect(1, -16, 15, 15);
    ctx.fillRect(-16, 1, 15, 15);
    ctx.fillRect(1, 1, 15, 15);
});
function clip(v, min, max) {
    return Math.min(max, Math.max(min, v));
}
vp.setClipPosition((p) => {
    p.scale = clip(p.scale, 0.1, 10.0);
    p.pos[0] = clip(p.pos[0], -256, 256);
    p.pos[1] = clip(p.pos[1], -256, 256);
    return p;
});
window.addEventListener("resize", vp.resize);
export class TouchDemux {
    constructor(e, h) {
        this.active = new Map();
        const start = (evt) => {
            evt.preventDefault();
            for (const t of evt.touches) {
                if (!this.active.has(t.identifier)) {
                    this.active.set(t.identifier, [t.clientX, t.clientY]);
                    h.start(t);
                }
            }
        };
        const move = (evt) => {
            evt.preventDefault();
            let moved = false;
            for (const t of evt.touches) {
                const a = this.active.get(t.identifier);
                if (a === undefined) {
                    throw new Error("Touch moved without being started");
                }
                if (a[0] != t.clientX || a[1] != t.clientY) {
                    moved = true;
                }
            }
            if (moved) {
                h.move(evt.touches);
            }
        };
        const end = (evt) => {
            evt.preventDefault();
            const removed = new Set(this.active.keys());
            for (const t of evt.touches) {
                removed.delete(t.identifier);
            }
            for (const id of removed) {
                this.active.delete(id);
                h.end(id);
            }
        };
        e.addEventListener("touchstart", start, false);
        e.addEventListener("touchmove", move, false);
        e.addEventListener("touchend", end, false);
        e.addEventListener("touchcancel", end, false);
    }
}
;
;
export class Gestures {
    constructor(h) {
        this.h = h;
        this.addTap = null;
        this.taps = new Map();
        this.pan = new Map();
    }
    endTap(tap, id, panning) {
        this.taps.delete(id);
        tap.active.delete(id);
        if (panning) {
            tap.positions.delete(id);
        }
        if (this.addTap === tap) {
            this.addTap = null;
        }
        if (tap.active.size === 0 && tap.positions.size > 0) {
            const positions = [];
            for (const p of tap.positions.values()) {
                positions.push(p.start);
            }
            this.h.tap(positions);
        }
    }
    start(t) {
        if (this.taps.has(t.identifier)) {
            throw new Error("Touch start on already tracked tap");
        }
        if (this.addTap === null) {
            // If no taps are active, set up a tap to add a touch to.
            this.addTap = {
                active: new Set(),
                positions: new Map(),
            };
        }
        this.addTap.active.add(t.identifier);
        const pos = [t.clientX, t.clientY];
        this.addTap.positions.set(t.identifier, {
            curr: pos,
            start: pos,
        });
        this.taps.set(t.identifier, this.addTap);
    }
    move(ts) {
        let panMoved = false;
        for (const t of ts) {
            const tap = this.taps.get(t.identifier);
            if (tap !== undefined) {
                const pos = tap.positions.get(t.identifier);
                if (pos === undefined) {
                    throw new Error("Touch in taps, but not positions");
                }
                pos.curr = [t.clientX, t.clientY];
                if (16 <= pointDistance(pos.curr, pos.start)) {
                    // Tap has moved enough to be a pan instead.
                    this.endTap(tap, t.identifier, true);
                    this.pan.set(t.identifier, {
                        curr: pos.curr,
                        prev: pos.start,
                        start: pos.start,
                    });
                    panMoved = true;
                }
            }
            else {
                const pos = this.pan.get(t.identifier);
                if (pos === undefined) {
                    throw new Error("Touch not in taps or pans");
                }
                pos.prev = pos.curr;
                pos.curr = [t.clientX, t.clientY];
                if (!pointEquals(pos.prev, pos.curr)) {
                    panMoved = true;
                }
            }
        }
        if (panMoved) {
            const positions = [];
            // NB: pan is in insertion order, so positions will be sent from oldest touch to newest.
            for (const p of this.pan.values()) {
                positions.push(p);
            }
            this.h.pan(positions);
        }
    }
    end(id) {
        const tap = this.taps.get(id);
        if (tap !== undefined) {
            this.endTap(tap, id, false);
        }
        else if (!this.pan.delete(id)) {
            throw new Error("Touch end that was not a tap or a pan");
        }
    }
}
;
// TODO: put this in it's own class
new TouchDemux(c, new Gestures({
    tap: (t) => {
        const s2w = vp.screen2world();
        console.log("tap: ", t, " world: ", transformPoint(s2w, t[0]));
    },
    pan: (ps) => {
        const pos = vp.position();
        const s2w = vp.screen2world();
        if (ps.length == 1) {
            const p = ps[ps.length - 1];
            const curr = transformPoint(s2w, p.curr);
            const prev = transformPoint(s2w, p.prev);
            vp.setPosition({
                pos: pointAdd(pos.pos, pointSub(prev, curr)),
            });
        }
        else if (ps.length >= 2) {
            const p1 = ps[ps.length - 1];
            const p2 = ps[ps.length - 2];
            const wp1prev = transformPoint(s2w, p1.prev);
            const curra = pointAngle(pointSub(p2.curr, p1.curr));
            const preva = pointAngle(pointSub(p2.prev, p1.prev));
            const currl = pointDistance(p1.curr, p2.curr);
            const prevl = pointDistance(p1.prev, p2.prev);
            const wp1curr = transformPoint(s2w, p1.curr);
            let t = transformTranslateCreate(-wp1curr[0], -wp1curr[1]);
            t = transformScale(t, prevl / currl);
            t = transformRotate(t, preva - curra);
            t = transformTranslate(t, wp1prev[0], wp1prev[1]);
            // TODO: why does this work? Isn't it backwards?
            vp.setPosition({
                pos: transformPoint(t, pos.pos),
                scale: pos.scale * currl / prevl,
                rotate: pos.rotate - preva + curra,
            });
        }
    },
}));
console.log("stuff loaded");
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWFpbi5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uL3NyYy9tYWluLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxRQUFRLEVBQW9CLE1BQU0sZUFBZSxDQUFBO0FBQzFELE9BQU8sRUFBVyxhQUFhLEVBQUUsV0FBVyxFQUFFLFFBQVEsRUFBRSxRQUFRLEVBQUUsVUFBVSxFQUFFLE1BQU0sWUFBWSxDQUFBO0FBQ2hHLE9BQU8sRUFBRSxjQUFjLEVBQUUsd0JBQXdCLEVBQUUsZUFBZSxFQUFFLGNBQWMsRUFBRSxrQkFBa0IsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBRS9ILE1BQU0sQ0FBQyxHQUFJLFFBQVEsQ0FBQyxjQUFjLENBQUMsUUFBUSxDQUF1QixDQUFDO0FBQ25FLElBQUksQ0FBQyxLQUFLLElBQUksRUFBRTtJQUNaLE1BQU0sSUFBSSxLQUFLLENBQUMsbUJBQW1CLENBQUMsQ0FBQztDQUN4QztBQUNELE1BQU0sR0FBRyxHQUFHLENBQUMsQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLENBQUM7QUFDL0IsSUFBSSxHQUFHLEtBQUssSUFBSSxFQUFFO0lBQ2QsTUFBTSxJQUFJLEtBQUssQ0FBQyxlQUFlLENBQUMsQ0FBQztDQUNwQztBQUNELE1BQU0sRUFBRSxHQUFHLElBQUksUUFBUSxDQUFDLEdBQUcsRUFBRSxHQUFHLEVBQUU7SUFDOUIsR0FBRyxDQUFDLFNBQVMsR0FBRyxPQUFPLENBQUM7SUFDeEIsR0FBRyxDQUFDLFFBQVEsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxDQUFDLENBQUM7SUFDL0IsR0FBRyxDQUFDLFFBQVEsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsQ0FBQyxDQUFDO0lBQzdCLEdBQUcsQ0FBQyxRQUFRLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxFQUFFLEVBQUUsRUFBRSxFQUFFLENBQUMsQ0FBQztJ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QUFFLEtBQUssR0FBRyxLQUFLLENBQUMsQ0FBQztZQUN0QyxDQUFDLEdBQUcsa0JBQWtCLENBQUMsQ0FBQyxFQUFFLE9BQU8sQ0FBQyxDQUFDLENBQUMsRUFBRSxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUNsRCxnREFBZ0Q7WUFFaEQsRUFBRSxDQUFDLFdBQVcsQ0FBQztnQkFDWCxHQUFHLEVBQUUsY0FBYyxDQUFDLENBQUMsRUFBRSxHQUFHLENBQUMsR0FBRyxDQUFDO2dCQUMvQixLQUFLLEVBQUUsR0FBRyxDQUFDLEtBQUssR0FBRyxLQUFLLEdBQUcsS0FBSztnQkFDaEMsTUFBTSxFQUFFLEdBQUcsQ0FBQyxNQUFNLEdBQUcsS0FBSyxHQUFHLEtBQUs7YUFDckMsQ0FBQyxDQUFDO1NBQ047SUFDTCxDQUFDO0NBQ0osQ0FBQyxDQUFDLENBQUM7QUFFSixPQUFPLENBQUMsR0FBRyxDQUFDLGNBQWMsQ0FBQyxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgVmlld3BvcnQsIFZpZXdwb3J0UG9zaXRpb24gfSBmcm9tIFwiLi92aWV3cG9ydC5qc1wiXG5pbXBvcnQgeyBQb2ludDJELCBwb2ludERpc3RhbmNlLCBwb2ludEVxdWFscywgcG9pbnRTdWIsIHBvaW50QWRkLCBwb2ludEFuZ2xlIH0gZnJvbSBcIi4vcG9pbnQuanNcIlxuaW1wb3J0IHsgdHJhbnNmb3JtUG9pbnQsIHRyYW5zZm9ybVRyYW5zbGF0ZUNyZWF0ZSwgdHJhbnNmb3JtUm90YXRlLCB0cmFuc2Zvcm1TY2FsZSwgdHJhbnNmb3JtVHJhbnNsYXRlIH0gZnJvbSBcIi4vdHJhbnNmb3JtLmpzXCI7XG5cbmNvbnN0IGMgPSAoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJjYW52YXNcIikgYXMgSFRNTENhbnZhc0VsZW1lbnQpO1xuaWYgKGMgPT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBjYW52YXMgZWxlbWVudFwiKTtcbn1cbmNvbnN0IGN0eCA9IGMuZ2V0Q29udGV4dChcIjJkXCIpO1xuaWYgKGN0eCA9PT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIk5vIDJkIGNvbnRleHRcIik7XG59XG5jb25zdCB2cCA9IG5ldyBWaWV3cG9ydChjdHgsICgpID0+IHtcbiAgICBjdHguZmlsbFN0eWxlID0gXCJibGFja1wiO1xuICAgIGN0eC5maWxsUmVjdCgtMTYsIC0xNiwgMTUsIDE1KTtcbiAgICBjdHguZmlsbFJlY3QoMSwgLTE2LCAxNSwgMTUpO1xuICAgIGN0eC5maWxsUmVjdCgtMTYsIDEsIDE1LCAxNSk7XG4gICAgY3R4LmZpbGxSZWN0KDEsIDEsIDE1LCAxNSk7XG59KTtcblxuZnVuY3Rpb24gY2xpcCh2OiBudW1iZXIsIG1pbjogbnVtYmVyLCBtYXg6IG51bWJlcik6IG51bWJlciB7XG4gICAgcmV0dXJuIE1hdGgubWluKG1heCwgTWF0aC5tYXgobWluLCB2KSk7XG59XG5cbnZwLnNldENsaXBQb3NpdGlvbigocDogVmlld3BvcnRQb3NpdGlvbik6IFZpZXdwb3J0UG9zaXRpb24gPT4ge1xuICAgIHAuc2NhbGUgPSBjbGlwKHAuc2NhbGUsIDAuMSwgMTAuMCk7XG4gICAgcC5wb3NbMF0gPSBjbGlwKHAucG9zWzBdLCAtMjU2LCAyNTYpO1xuICAgIHAucG9zWzFdID0gY2xpcChwLnBvc1sxXSwgLTI1NiwgMjU2KTtcbiAgICByZXR1cm4gcDtcbn0pO1xuXG53aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCB2cC5yZXNpemUpO1xuXG4vLyBUT0RPOiBUb3VjaERlbXV4IGluIGl0cyBvd24gZmlsZVxuZXhwb3J0IGludGVyZmFjZSBUb3VjaEhhbmRsZXIge1xuICAgIHN0YXJ0OiAodDogVG91Y2gpID0+IHZvaWQ7XG4gICAgbW92ZTogKHRzOiBUb3VjaExpc3QpID0+IHZvaWQ7XG4gICAgZW5kOiAoaWQ6IG51bWJlcikgPT4gdm9pZDtcbn1cblxuZXhwb3J0IGNsYXNzIFRvdWNoRGVtdXgge1xuICAgIC8vIE1hcCBvZiBhY3RpdmUgdG91Y2ggSURzIHRvIHRoZWlyIGNvb3JkaW5hdGVzXG4gICAgcHJpdmF0ZSBhY3RpdmU6IE1hcDxudW1iZXIsIFBvaW50MkQ+O1xuXG4gICAgY29uc3RydWN0b3IoZTogSFRNTEVsZW1lbnQsIGg6IFRvdWNoSGFuZGxlcikge1xuICAgICAgICB0aGlzLmFjdGl2ZSA9IG5ldyBNYXA8bnVtYmVyLCBQb2ludDJEPigpO1xuXG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gKGV2dDogVG91Y2hFdmVudCkgPT4ge1xuICAgICAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHQgb2YgZXZ0LnRvdWNoZXMpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuYWN0aXZlLmhhcyh0LmlkZW50aWZpZXIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWN0aXZlLnNldCh0LmlkZW50aWZpZXIsIFt0LmNsaWVudFgsIHQuY2xpZW50WV0pO1xuICAgICAgICAgICAgICAgICAgICBoLnN0YXJ0KHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTsgXG4gICAgICAgIGNvbnN0IG1vdmUgPSAoZXZ0OiBUb3VjaEV2ZW50KSA9PiB7XG4gICAgICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIGxldCBtb3ZlZCA9IGZhbHNlO1xuICAgICAgICAgICAgZm9yIChjb25zdCB0IG9mIGV2dC50b3VjaGVzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYSA9IHRoaXMuYWN0aXZlLmdldCh0LmlkZW50aWZpZXIpO1xuICAgICAgICAgICAgICAgIGlmIChhID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVG91Y2ggbW92ZWQgd2l0aG91dCBiZWluZyBzdGFydGVkXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoYVswXSAhPSB0LmNsaWVudFggfHwgYVsxXSAhPSB0LmNsaWVudFkpIHtcbiAgICAgICAgICAgICAgICAgICAgbW92ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtb3ZlZCkge1xuICAgICAgICAgICAgICAgIGgubW92ZShldnQudG91Y2hlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGVuZCA9IChldnQ6IFRvdWNoRXZlbnQpID0+IHtcbiAgICAgICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIFxuICAgICAgICAgICAgY29uc3QgcmVtb3ZlZCA9IG5ldyBTZXQ8bnVtYmVyPih0aGlzLmFjdGl2ZS5rZXlzKCkpO1xuICAgICAgICAgICAgZm9yIChjb25zdCB0IG9mIGV2dC50b3VjaGVzKSB7XG4gICAgICAgICAgICAgICAgcmVtb3ZlZC5kZWxldGUodC5pZGVudGlmaWVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoY29uc3QgaWQgb2YgcmVtb3ZlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuYWN0aXZlLmRlbGV0ZShpZCk7XG4gICAgICAgICAgICAgICAgaC5lbmQoaWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBlLmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaHN0YXJ0XCIsIHN0YXJ0LCBmYWxzZSk7XG4gICAgICAgIGUuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNobW92ZVwiLCBtb3ZlLCBmYWxzZSk7XG4gICAgICAgIGUuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNoZW5kXCIsIGVuZCwgZmFsc2UpO1xuICAgICAgICBlLmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaGNhbmNlbFwiLCBlbmQsIGZhbHNlKTtcbiAgICB9XG59O1xuXG4vLyBUT0RPOiBHZXN0dXJlIGluIGl0cyBvd24gZmlsZVxuZXhwb3J0IHR5cGUgVGFwID0gQXJyYXk8UG9pbnQyRD47XG5cbmV4cG9ydCB0eXBlIFBhbiA9IEFycmF5PHtcbiAgICBzdGFydDogUG9pbnQyRDtcbiAgICBwcmV2OiBQb2ludDJEO1xuICAgIGN1cnI6IFBvaW50MkQ7XG59PjtcblxuZXhwb3J0IGludGVyZmFjZSBHZXN0dXJlSGFuZGxlciB7XG4gICAgdGFwOiAodDogVGFwKSA9PiB2b2lkO1xuICAgIHBhbjogKHA6IFBhbikgPT4gdm9pZDtcbn07XG5cbi8vIFRvdWNoIGhhbmRsaW5nXG4vLyAqIGRldGVjdCBpZiBhIHRvdWNoIGlzIGEgdGFwIG9yIGEgcGFuXG4vLyAgICogdGFwcyBkb24ndCBtb3ZlIG1vcmUgdGhhbiAxNiBwaXhlbHNcbi8vICAgKiBtYXliZTogdGFwcyBhcmUgZmFzdGVyIHRoYW4geDAwbXMsIFRPRE86IGluc3RydW1lbnQgYW5kIGZpbmQgb3V0IHdoYXQgZmVlbHMgT0tcbi8vICogcHJvY2VzcyB0YXBzXG4vLyAgICogZmlyc3QgdG91Y2ggc3RhcnRzIGFjdGl2ZSB0YXBcbi8vICAgKiBhbGwgc3Vic2VxdWVudCB0b3VjaGVzIGFkZGVkIHRvIHRhcFxuLy8gICAqIHRhcCBhY3RpdmUgdW50aWwgZmlyc3QgdG91Y2ggZW5kXG4vLyAgICogdGFwIGZpcmVzIHdoZW4gb24gbGFzdCB0b3VjaCBlbmQgKG9yIHRvdWNoIGNvbnZlcnRlZCB0byBwYW4pLCB1bmxlc3Mgbm8gdGFwcyByZW1haW4gKGFsbCBjb252ZXJ0ZWQgdG8gcGFuKVxuLy8gICAqIG5ldyBhY3RpdmUgdGFwIGNhbiBzdGFydCB3aGlsZSBvbGQgb25lIGlzIHJ1bm5pbmcgYnV0IG5vbG9uZ2VyIGFjdGl2ZVxuLy8gKiBhbGwgcGFucyBnZXQgcHV0IGludG8gYSBzaW5nbGUgcGFuIHRyYWNrZXJcblxudHlwZSBBY3RpdmVUYXAgPSB7XG4gICAgYWN0aXZlOiBTZXQ8bnVtYmVyPjtcbiAgICBwb3NpdGlvbnM6IE1hcDxudW1iZXIsIHtcbiAgICAgICAgY3VycjogUG9pbnQyRCxcbiAgICAgICAgc3RhcnQ6IFBvaW50MkQsXG4gICAgfT47XG59O1xuXG50eXBlIEFjdGl2ZVBhbiA9IE1hcDxudW1iZXIsIHtcbiAgICBjdXJyOiBQb2ludDJELFxuICAgIHByZXY6IFBvaW50MkQsXG4gICAgc3RhcnQ6IFBvaW50MkQsXG59PjtcblxuZXhwb3J0IGNsYXNzIEdlc3R1cmVzIGltcGxlbWVudHMgVG91Y2hIYW5kbGVyIHtcbiAgICBwcml2YXRlIGg6IEdlc3R1cmVIYW5kbGVyO1xuICAgIHByaXZhdGUgYWRkVGFwOiBBY3RpdmVUYXAgfCBudWxsO1xuICAgIHByaXZhdGUgdGFwczogTWFwPG51bWJlciwgQWN0aXZlVGFwPjtcbiAgICBwcml2YXRlIHBhbjogQWN0aXZlUGFuO1xuXG4gICAgcHJpdmF0ZSBlbmRUYXAodGFwOiBBY3RpdmVUYXAsIGlkOiBudW1iZXIsIHBhbm5pbmc6IGJvb2xlYW4pIHtcbiAgICAgICAgdGhpcy50YXBzLmRlbGV0ZShpZCk7XG4gICAgICAgIHRhcC5hY3RpdmUuZGVsZXRlKGlkKTtcbiAgICAgICAgaWYgKHBhbm5pbmcpIHtcbiAgICAgICAgICAgIHRhcC5wb3NpdGlvbnMuZGVsZXRlKGlkKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5hZGRUYXAgPT09IHRhcCkge1xuICAgICAgICAgICAgdGhpcy5hZGRUYXAgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0YXAuYWN0aXZlLnNpemUgPT09IDAgJiYgdGFwLnBvc2l0aW9ucy5zaXplID4gMCkge1xuICAgICAgICAgICAgY29uc3QgcG9zaXRpb25zID0gW107XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHAgb2YgdGFwLnBvc2l0aW9ucy52YWx1ZXMoKSkge1xuICAgICAgICAgICAgICAgIHBvc2l0aW9ucy5wdXNoKHAuc3RhcnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5oLnRhcChwb3NpdGlvbnMpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgY29uc3RydWN0b3IoaDogR2VzdHVyZUhhbmRsZXIpIHtcbiAgICAgICAgdGhpcy5oID0gaDtcbiAgICAgICAgdGhpcy5hZGRUYXAgPSBudWxsO1xuICAgICAgICB0aGlzLnRhcHMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMucGFuID0gbmV3IE1hcCgpO1xuICAgIH1cblxuICAgIHN0YXJ0KHQ6IFRvdWNoKSB7XG4gICAgICAgIGlmICh0aGlzLnRhcHMuaGFzKHQuaWRlbnRpZmllcikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRvdWNoIHN0YXJ0IG9uIGFscmVhZHkgdHJhY2tlZCB0YXBcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuYWRkVGFwID09PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBJZiBubyB0YXBzIGFyZSBhY3RpdmUsIHNldCB1cCBhIHRhcCB0byBhZGQgYSB0b3VjaCB0by5cbiAgICAgICAgICAgIHRoaXMuYWRkVGFwID0ge1xuICAgICAgICAgICAgICAgIGFjdGl2ZTogbmV3IFNldCgpLFxuICAgICAgICAgICAgICAgIHBvc2l0aW9uczogbmV3IE1hcCgpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFkZFRhcC5hY3RpdmUuYWRkKHQuaWRlbnRpZmllcik7XG4gICAgICAgIGNvbnN0IHBvczogUG9pbnQyRCA9IFt0LmNsaWVudFgsIHQuY2xpZW50WV07XG4gICAgICAgIHRoaXMuYWRkVGFwLnBvc2l0aW9ucy5zZXQodC5pZGVudGlmaWVyLCB7XG4gICAgICAgICAgICBjdXJyOiBwb3MsXG4gICAgICAgICAgICBzdGFydDogcG9zLFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy50YXBzLnNldCh0LmlkZW50aWZpZXIsIHRoaXMuYWRkVGFwKTtcbiAgICB9XG5cbiAgICBtb3ZlKHRzOiBUb3VjaExpc3QpIHtcbiAgICAgICAgbGV0IHBhbk1vdmVkID0gZmFsc2U7XG4gICAgICAgIGZvciAoY29uc3QgdCBvZiB0cykge1xuICAgICAgICAgICAgY29uc3QgdGFwID0gdGhpcy50YXBzLmdldCh0LmlkZW50aWZpZXIpO1xuICAgICAgICAgICAgaWYgKHRhcCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcG9zID0gdGFwLnBvc2l0aW9ucy5nZXQodC5pZGVudGlmaWVyKTtcbiAgICAgICAgICAgICAgICBpZiAocG9zID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVG91Y2ggaW4gdGFwcywgYnV0IG5vdCBwb3NpdGlvbnNcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHBvcy5jdXJyID0gW3QuY2xpZW50WCwgdC5jbGllbnRZXTtcbiAgICAgICAgICAgICAgICBpZiAoMTYgPD0gcG9pbnREaXN0YW5jZShwb3MuY3VyciwgcG9zLnN0YXJ0KSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBUYXAgaGFzIG1vdmVkIGVub3VnaCB0byBiZSBhIHBhbiBpbnN0ZWFkLlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmVuZFRhcCh0YXAsIHQuaWRlbnRpZmllciwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGFuLnNldCh0LmlkZW50aWZpZXIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnI6IHBvcy5jdXJyLFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJldjogcG9zLnN0YXJ0LFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IHBvcy5zdGFydCxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHBhbk1vdmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBvcyA9IHRoaXMucGFuLmdldCh0LmlkZW50aWZpZXIpO1xuICAgICAgICAgICAgICAgIGlmIChwb3MgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUb3VjaCBub3QgaW4gdGFwcyBvciBwYW5zXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwb3MucHJldiA9IHBvcy5jdXJyO1xuICAgICAgICAgICAgICAgIHBvcy5jdXJyID0gW3QuY2xpZW50WCwgdC5jbGllbnRZXTtcbiAgICAgICAgICAgICAgICBpZiAoIXBvaW50RXF1YWxzKHBvcy5wcmV2LCBwb3MuY3VycikpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFuTW92ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocGFuTW92ZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IHBvc2l0aW9ucyA9IFtdO1xuICAgICAgICAgICAgLy8gTkI6IHBhbiBpcyBpbiBpbnNlcnRpb24gb3JkZXIsIHNvIHBvc2l0aW9ucyB3aWxsIGJlIHNlbnQgZnJvbSBvbGRlc3QgdG91Y2ggdG8gbmV3ZXN0LlxuICAgICAgICAgICAgZm9yIChjb25zdCBwIG9mIHRoaXMucGFuLnZhbHVlcygpKSB7XG4gICAgICAgICAgICAgICAgcG9zaXRpb25zLnB1c2gocCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmgucGFuKHBvc2l0aW9ucyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBlbmQoaWQ6IG51bWJlcikge1xuICAgICAgICBjb25zdCB0YXAgPSB0aGlzLnRhcHMuZ2V0KGlkKTtcbiAgICAgICAgaWYgKHRhcCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmVuZFRhcCh0YXAsIGlkLCBmYWxzZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoIXRoaXMucGFuLmRlbGV0ZShpZCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRvdWNoIGVuZCB0aGF0IHdhcyBub3QgYSB0YXAgb3IgYSBwYW5cIik7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG4vLyBUT0RPOiBwdXQgdGhpcyBpbiBpdCdzIG93biBjbGFzc1xubmV3IFRvdWNoRGVtdXgoYywgbmV3IEdlc3R1cmVzKHtcbiAgICB0YXA6ICh0OiBUYXApID0+IHtcbiAgICAgICAgY29uc3QgczJ3ID0gdnAuc2NyZWVuMndvcmxkKCk7XG4gICAgICAgIGNvbnNvbGUubG9nKFwidGFwOiBcIiwgdCwgXCIgd29ybGQ6IFwiLCB0cmFuc2Zvcm1Qb2ludChzMncsIHRbMF0pKTtcbiAgICB9LFxuICAgIHBhbjogKHBzOiBQYW4pID0+IHtcbiAgICAgICAgY29uc3QgcG9zID0gdnAucG9zaXRpb24oKTtcbiAgICAgICAgY29uc3QgczJ3ID0gdnAuc2NyZWVuMndvcmxkKCk7XG4gICAgICAgIGlmIChwcy5sZW5ndGggPT0gMSkge1xuICAgICAgICAgICAgY29uc3QgcCA9IHBzW3BzLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgY29uc3QgY3VyciA9IHRyYW5zZm9ybVBvaW50KHMydywgcC5jdXJyKTtcbiAgICAgICAgICAgIGNvbnN0IHByZXYgPSB0cmFuc2Zvcm1Qb2ludChzMncsIHAucHJldik7XG4gICAgICAgICAgICB2cC5zZXRQb3NpdGlvbih7XG4gICAgICAgICAgICAgICAgcG9zOiBwb2ludEFkZChwb3MucG9zLCBwb2ludFN1YihwcmV2LCBjdXJyKSksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIGlmIChwcy5sZW5ndGggPj0gMikge1xuICAgICAgICAgICAgY29uc3QgcDEgPSBwc1twcy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIGNvbnN0IHAyID0gcHNbcHMubGVuZ3RoIC0gMl07XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGNvbnN0IHdwMXByZXYgPSB0cmFuc2Zvcm1Qb2ludChzMncsIHAxLnByZXYpO1xuICAgICAgICAgICAgY29uc3QgY3VycmEgPSBwb2ludEFuZ2xlKHBvaW50U3ViKHAyLmN1cnIsIHAxLmN1cnIpKTtcbiAgICAgICAgICAgIGNvbnN0IHByZXZhID0gcG9pbnRBbmdsZShwb2ludFN1YihwMi5wcmV2LCBwMS5wcmV2KSk7XG4gICAgICAgICAgICBjb25zdCBjdXJybCA9IHBvaW50RGlzdGFuY2UocDEuY3VyciwgcDIuY3Vycik7XG4gICAgICAgICAgICBjb25zdCBwcmV2bCA9IHBvaW50RGlzdGFuY2UocDEucHJldiwgcDIucHJldik7XG4gICAgICAgICAgICBjb25zdCB3cDFjdXJyID0gdHJhbnNmb3JtUG9pbnQoczJ3LCBwMS5jdXJyKTtcbiAgICAgICAgICAgIGxldCB0ID0gdHJhbnNmb3JtVHJhbnNsYXRlQ3JlYXRlKC13cDFjdXJyWzBdLCAtd3AxY3VyclsxXSk7XG4gICAgICAgICAgICB0ID0gdHJhbnNmb3JtU2NhbGUodCwgcHJldmwgLyBjdXJybCk7XG4gICAgICAgICAgICB0ID0gdHJhbnNmb3JtUm90YXRlKHQsIHByZXZhIC0gY3VycmEpO1xuICAgICAgICAgICAgdCA9IHRyYW5zZm9ybVRyYW5zbGF0ZSh0LCB3cDFwcmV2WzBdLCB3cDFwcmV2WzFdKTtcbiAgICAgICAgICAgIC8vIFRPRE86IHdoeSBkb2VzIHRoaXMgd29yaz8gSXNuJ3QgaXQgYmFja3dhcmRzP1xuXG4gICAgICAgICAgICB2cC5zZXRQb3NpdGlvbih7XG4gICAgICAgICAgICAgICAgcG9zOiB0cmFuc2Zvcm1Qb2ludCh0LCBwb3MucG9zKSxcbiAgICAgICAgICAgICAgICBzY2FsZTogcG9zLnNjYWxlICogY3VycmwgLyBwcmV2bCxcbiAgICAgICAgICAgICAgICByb3RhdGU6IHBvcy5yb3RhdGUgLSBwcmV2YSArIGN1cnJhLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9LFxufSkpO1xuXG5jb25zb2xlLmxvZyhcInN0dWZmIGxvYWRlZFwiKTtcbiJdfQ==