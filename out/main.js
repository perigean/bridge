import { Viewport } from "./viewport.js";
import { pointDistance, pointEquals, pointSub, pointAdd, pointAngle } from "./point.js";
import { transformPoint, transformTranslateCreate, transformRotate, transformScale, transformTranslate } from "./transform.js";
const c = document.getElementById("canvas");
if (c === null) {
    throw new Error("No canvas element");
}
const ctx = c.getContext("2d");
if (ctx === null) {
    throw new Error("No 2d context");
}
const vp = new Viewport(ctx, () => {
    ctx.fillStyle = "black";
    ctx.fillRect(-16, -16, 15, 15);
    ctx.fillRect(1, -16, 15, 15);
    ctx.fillRect(-16, 1, 15, 15);
    ctx.fillRect(1, 1, 15, 15);
});
window.addEventListener("resize", vp.resize);
export class TouchDemux {
    constructor(e, h) {
        this.active = new Map();
        const start = (evt) => {
            evt.preventDefault();
            for (const t of evt.touches) {
                if (!this.active.has(t.identifier)) {
                    this.active.set(t.identifier, [t.clientX, t.clientY]);
                    h.start(t);
                }
            }
        };
        const move = (evt) => {
            evt.preventDefault();
            let moved = false;
            for (const t of evt.touches) {
                const a = this.active.get(t.identifier);
                if (a === undefined) {
                    throw new Error("Touch moved without being started");
                }
                if (a[0] != t.clientX || a[1] != t.clientY) {
                    moved = true;
                }
            }
            if (moved) {
                h.move(evt.touches);
            }
        };
        const end = (evt) => {
            evt.preventDefault();
            const removed = new Set(this.active.keys());
            for (const t of evt.touches) {
                removed.delete(t.identifier);
            }
            for (const id of removed) {
                this.active.delete(id);
                h.end(id);
            }
        };
        e.addEventListener("touchstart", start, false);
        e.addEventListener("touchmove", move, false);
        e.addEventListener("touchend", end, false);
        e.addEventListener("touchcancel", end, false);
    }
}
;
;
export class Gestures {
    constructor(h) {
        this.h = h;
        this.addTap = null;
        this.taps = new Map();
        this.pan = new Map();
    }
    endTap(tap, id, panning) {
        this.taps.delete(id);
        tap.active.delete(id);
        if (panning) {
            tap.positions.delete(id);
        }
        if (this.addTap === tap) {
            this.addTap = null;
        }
        if (tap.active.size === 0 && tap.positions.size > 0) {
            const positions = [];
            for (const p of tap.positions.values()) {
                positions.push(p.start);
            }
            this.h.tap(positions);
        }
    }
    start(t) {
        if (this.taps.has(t.identifier)) {
            throw new Error("Touch start on already tracked tap");
        }
        if (this.addTap === null) {
            // If no taps are active, set up a tap to add a touch to.
            this.addTap = {
                active: new Set(),
                positions: new Map(),
            };
        }
        this.addTap.active.add(t.identifier);
        const pos = [t.clientX, t.clientY];
        this.addTap.positions.set(t.identifier, {
            curr: pos,
            start: pos,
        });
        this.taps.set(t.identifier, this.addTap);
    }
    move(ts) {
        let panMoved = false;
        for (const t of ts) {
            const tap = this.taps.get(t.identifier);
            if (tap !== undefined) {
                const pos = tap.positions.get(t.identifier);
                if (pos === undefined) {
                    throw new Error("Touch in taps, but not positions");
                }
                pos.curr = [t.clientX, t.clientY];
                if (16 <= pointDistance(pos.curr, pos.start)) {
                    // Tap has moved enough to be a pan instead.
                    this.endTap(tap, t.identifier, true);
                    this.pan.set(t.identifier, {
                        curr: pos.curr,
                        prev: pos.start,
                        start: pos.start,
                    });
                    panMoved = true;
                }
            }
            else {
                const pos = this.pan.get(t.identifier);
                if (pos === undefined) {
                    throw new Error("Touch not in taps or pans");
                }
                pos.prev = pos.curr;
                pos.curr = [t.clientX, t.clientY];
                if (!pointEquals(pos.prev, pos.curr)) {
                    panMoved = true;
                }
            }
        }
        if (panMoved) {
            const positions = [];
            // NB: pan is in insertion order, so positions will be sent from oldest touch to newest.
            for (const p of this.pan.values()) {
                positions.push(p);
            }
            this.h.pan(positions);
        }
    }
    end(id) {
        const tap = this.taps.get(id);
        if (tap !== undefined) {
            this.endTap(tap, id, false);
        }
        else if (!this.pan.delete(id)) {
            throw new Error("Touch end that was not a tap or a pan");
        }
    }
}
;
// TODO: put this in it's own class
new TouchDemux(c, new Gestures({
    tap: (t) => {
        const s2w = vp.screen2world();
        console.log("tap: ", t, " world: ", transformPoint(s2w, t[0]));
    },
    pan: (ps) => {
        const pos = vp.position();
        const s2w = vp.screen2world();
        if (ps.length == 1) {
            const p = ps[ps.length - 1];
            const curr = transformPoint(s2w, p.curr);
            const prev = transformPoint(s2w, p.prev);
            vp.setPosition({
                pos: pointAdd(pos.pos, pointSub(prev, curr)),
            });
        }
        else if (ps.length >= 2) {
            const p1 = ps[ps.length - 1];
            const p2 = ps[ps.length - 2];
            const wp1prev = transformPoint(s2w, p1.prev);
            const curra = pointAngle(pointSub(p2.curr, p1.curr));
            const preva = pointAngle(pointSub(p2.prev, p1.prev));
            const currl = pointDistance(p1.curr, p2.curr);
            const prevl = pointDistance(p1.prev, p2.prev);
            const wp1curr = transformPoint(s2w, p1.curr);
            let t = transformTranslateCreate(-wp1curr[0], -wp1curr[1]);
            t = transformScale(t, prevl / currl);
            t = transformRotate(t, preva - curra);
            t = transformTranslate(t, wp1prev[0], wp1prev[1]);
            // TODO: why does this work? Isn't it backwards?
            vp.setPosition({
                pos: transformPoint(t, pos.pos),
                scale: pos.scale * currl / prevl,
                rotate: pos.rotate - preva + curra,
            });
        }
    },
}));
console.log("stuff loaded");
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWFpbi5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uL3NyYy9tYWluLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxRQUFRLEVBQW9CLE1BQU0sZUFBZSxDQUFBO0FBQzFELE9BQU8sRUFBVyxhQUFhLEVBQUUsV0FBVyxFQUFFLFFBQVEsRUFBRSxRQUFRLEVBQUUsVUFBVSxFQUFFLE1BQU0sWUFBWSxDQUFBO0FBQ2hHLE9BQU8sRUFBRSxjQUFjLEVBQUUsd0JBQXdCLEVBQUUsZUFBZSxFQUFFLGNBQWMsRUFBRSxrQkFBa0IsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBRS9ILE1BQU0sQ0FBQyxHQUFJLFFBQVEsQ0FBQyxjQUFjLENBQUMsUUFBUSxDQUF1QixDQUFDO0FBQ25FLElBQUksQ0FBQyxLQUFLLElBQUksRUFBRTtJQUNaLE1BQU0sSUFBSSxLQUFLLENBQUMsbUJBQW1CLENBQUMsQ0FBQztDQUN4QztBQUNELE1BQU0sR0FBRyxHQUFHLENBQUMsQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLENBQUM7QUFDL0IsSUFBSSxHQUFHLEtBQUssSUFBSSxFQUFFO0lBQ2QsTUFBTSxJQUFJLEtBQUssQ0FBQyxlQUFlLENBQUMsQ0FBQztDQUNwQztBQUNELE1BQU0sRUFBRSxHQUFHLElBQUksUUFBUSxDQUFDLEdBQUcsRUFBRSxHQUFHLEVBQUU7SUFDOUIsR0FBRyxDQUFDLFNBQVMsR0FBRyxPQUFPLENBQUM7SUFDeEIsR0FBRyxDQUFDLFFBQVEsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxDQUFDLENBQUM7SUFDL0IsR0FBRyxDQUFDLFFBQVEsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsQ0FBQyxDQUFDO0lBQzdCLEdBQUcsQ0FBQyxRQUFRLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxFQUFFLEVBQUUsRUFBRSxFQUFFLENBQUMsQ0FBQztJ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QUFDLElBQUksQ0FBQyxDQUFDO1lBQzlDLE1BQU0sS0FBSyxHQUFHLGFBQWEsQ0FBQyxFQUFFLENBQUMsSUFBSSxFQUFFLEVBQUUsQ0FBQyxJQUFJLENBQUMsQ0FBQztZQUM5QyxNQUFNLE9BQU8sR0FBRyxjQUFjLENBQUMsR0FBRyxFQUFFLEVBQUUsQ0FBQyxJQUFJLENBQUMsQ0FBQztZQUM3QyxJQUFJLENBQUMsR0FBRyx3QkFBd0IsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQzNELENBQUMsR0FBRyxjQUFjLENBQUMsQ0FBQyxFQUFFLEtBQUssR0FBRyxLQUFLLENBQUMsQ0FBQztZQUNyQyxDQUFDLEdBQUcsZUFBZSxDQUFDLENBQUMsRUFBRSxLQUFLLEdBQUcsS0FBSyxDQUFDLENBQUM7WUFDdEMsQ0FBQyxHQUFHLGtCQUFrQixDQUFDLENBQUMsRUFBRSxPQUFPLENBQUMsQ0FBQyxDQUFDLEVBQUUsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDbEQsZ0RBQWdEO1lBRWhELEVBQUUsQ0FBQyxXQUFXLENBQUM7Z0JBQ1gsR0FBRyxFQUFFLGNBQWMsQ0FBQyxDQUFDLEVBQUUsR0FBRyxDQUFDLEdBQUcsQ0FBQztnQkFDL0IsS0FBSyxFQUFFLEdBQUcsQ0FBQyxLQUFLLEdBQUcsS0FBSyxHQUFHLEtBQUs7Z0JBQ2hDLE1BQU0sRUFBRSxHQUFHLENBQUMsTUFBTSxHQUFHLEtBQUssR0FBRyxLQUFLO2FBQ3JDLENBQUMsQ0FBQztTQUNOO0lBQ0wsQ0FBQztDQUNKLENBQUMsQ0FBQyxDQUFDO0FBRUosT0FBTyxDQUFDLEdBQUcsQ0FBQyxjQUFjLENBQUMsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFZpZXdwb3J0LCBWaWV3cG9ydFBvc2l0aW9uIH0gZnJvbSBcIi4vdmlld3BvcnQuanNcIlxuaW1wb3J0IHsgUG9pbnQyRCwgcG9pbnREaXN0YW5jZSwgcG9pbnRFcXVhbHMsIHBvaW50U3ViLCBwb2ludEFkZCwgcG9pbnRBbmdsZSB9IGZyb20gXCIuL3BvaW50LmpzXCJcbmltcG9ydCB7IHRyYW5zZm9ybVBvaW50LCB0cmFuc2Zvcm1UcmFuc2xhdGVDcmVhdGUsIHRyYW5zZm9ybVJvdGF0ZSwgdHJhbnNmb3JtU2NhbGUsIHRyYW5zZm9ybVRyYW5zbGF0ZSB9IGZyb20gXCIuL3RyYW5zZm9ybS5qc1wiO1xuXG5jb25zdCBjID0gKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiY2FudmFzXCIpIGFzIEhUTUxDYW52YXNFbGVtZW50KTtcbmlmIChjID09PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gY2FudmFzIGVsZW1lbnRcIik7XG59XG5jb25zdCBjdHggPSBjLmdldENvbnRleHQoXCIyZFwiKTtcbmlmIChjdHggPT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyAyZCBjb250ZXh0XCIpO1xufVxuY29uc3QgdnAgPSBuZXcgVmlld3BvcnQoY3R4LCAoKSA9PiB7XG4gICAgY3R4LmZpbGxTdHlsZSA9IFwiYmxhY2tcIjtcbiAgICBjdHguZmlsbFJlY3QoLTE2LCAtMTYsIDE1LCAxNSk7XG4gICAgY3R4LmZpbGxSZWN0KDEsIC0xNiwgMTUsIDE1KTtcbiAgICBjdHguZmlsbFJlY3QoLTE2LCAxLCAxNSwgMTUpO1xuICAgIGN0eC5maWxsUmVjdCgxLCAxLCAxNSwgMTUpO1xufSk7XG5cbndpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIHZwLnJlc2l6ZSk7XG5cbi8vIFRPRE86IFRvdWNoRGVtdXggaW4gaXRzIG93biBmaWxlXG5leHBvcnQgaW50ZXJmYWNlIFRvdWNoSGFuZGxlciB7XG4gICAgc3RhcnQ6ICh0OiBUb3VjaCkgPT4gdm9pZDtcbiAgICBtb3ZlOiAodHM6IFRvdWNoTGlzdCkgPT4gdm9pZDtcbiAgICBlbmQ6IChpZDogbnVtYmVyKSA9PiB2b2lkO1xufVxuXG5leHBvcnQgY2xhc3MgVG91Y2hEZW11eCB7XG4gICAgLy8gTWFwIG9mIGFjdGl2ZSB0b3VjaCBJRHMgdG8gdGhlaXIgY29vcmRpbmF0ZXNcbiAgICBwcml2YXRlIGFjdGl2ZTogTWFwPG51bWJlciwgUG9pbnQyRD47XG5cbiAgICBjb25zdHJ1Y3RvcihlOiBIVE1MRWxlbWVudCwgaDogVG91Y2hIYW5kbGVyKSB7XG4gICAgICAgIHRoaXMuYWN0aXZlID0gbmV3IE1hcDxudW1iZXIsIFBvaW50MkQ+KCk7XG5cbiAgICAgICAgY29uc3Qgc3RhcnQgPSAoZXZ0OiBUb3VjaEV2ZW50KSA9PiB7XG4gICAgICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgdCBvZiBldnQudG91Y2hlcykge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5hY3RpdmUuaGFzKHQuaWRlbnRpZmllcikpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hY3RpdmUuc2V0KHQuaWRlbnRpZmllciwgW3QuY2xpZW50WCwgdC5jbGllbnRZXSk7XG4gICAgICAgICAgICAgICAgICAgIGguc3RhcnQodCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9OyBcbiAgICAgICAgY29uc3QgbW92ZSA9IChldnQ6IFRvdWNoRXZlbnQpID0+IHtcbiAgICAgICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgbGV0IG1vdmVkID0gZmFsc2U7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHQgb2YgZXZ0LnRvdWNoZXMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBhID0gdGhpcy5hY3RpdmUuZ2V0KHQuaWRlbnRpZmllcik7XG4gICAgICAgICAgICAgICAgaWYgKGEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUb3VjaCBtb3ZlZCB3aXRob3V0IGJlaW5nIHN0YXJ0ZWRcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChhWzBdICE9IHQuY2xpZW50WCB8fCBhWzFdICE9IHQuY2xpZW50WSkge1xuICAgICAgICAgICAgICAgICAgICBtb3ZlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1vdmVkKSB7XG4gICAgICAgICAgICAgICAgaC5tb3ZlKGV2dC50b3VjaGVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgZW5kID0gKGV2dDogVG91Y2hFdmVudCkgPT4ge1xuICAgICAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgXG4gICAgICAgICAgICBjb25zdCByZW1vdmVkID0gbmV3IFNldDxudW1iZXI+KHRoaXMuYWN0aXZlLmtleXMoKSk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHQgb2YgZXZ0LnRvdWNoZXMpIHtcbiAgICAgICAgICAgICAgICByZW1vdmVkLmRlbGV0ZSh0LmlkZW50aWZpZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChjb25zdCBpZCBvZiByZW1vdmVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hY3RpdmUuZGVsZXRlKGlkKTtcbiAgICAgICAgICAgICAgICBoLmVuZChpZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGUuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNoc3RhcnRcIiwgc3RhcnQsIGZhbHNlKTtcbiAgICAgICAgZS5hZGRFdmVudExpc3RlbmVyKFwidG91Y2htb3ZlXCIsIG1vdmUsIGZhbHNlKTtcbiAgICAgICAgZS5hZGRFdmVudExpc3RlbmVyKFwidG91Y2hlbmRcIiwgZW5kLCBmYWxzZSk7XG4gICAgICAgIGUuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNoY2FuY2VsXCIsIGVuZCwgZmFsc2UpO1xuICAgIH1cbn07XG5cbi8vIFRPRE86IEdlc3R1cmUgaW4gaXRzIG93biBmaWxlXG5leHBvcnQgdHlwZSBUYXAgPSBBcnJheTxQb2ludDJEPjtcblxuZXhwb3J0IHR5cGUgUGFuID0gQXJyYXk8e1xuICAgIHN0YXJ0OiBQb2ludDJEO1xuICAgIHByZXY6IFBvaW50MkQ7XG4gICAgY3VycjogUG9pbnQyRDtcbn0+O1xuXG5leHBvcnQgaW50ZXJmYWNlIEdlc3R1cmVIYW5kbGVyIHtcbiAgICB0YXA6ICh0OiBUYXApID0+IHZvaWQ7XG4gICAgcGFuOiAocDogUGFuKSA9PiB2b2lkO1xufTtcblxuLy8gVG91Y2ggaGFuZGxpbmdcbi8vICogZGV0ZWN0IGlmIGEgdG91Y2ggaXMgYSB0YXAgb3IgYSBwYW5cbi8vICAgKiB0YXBzIGRvbid0IG1vdmUgbW9yZSB0aGFuIDE2IHBpeGVsc1xuLy8gICAqIG1heWJlOiB0YXBzIGFyZSBmYXN0ZXIgdGhhbiB4MDBtcywgVE9ETzogaW5zdHJ1bWVudCBhbmQgZmluZCBvdXQgd2hhdCBmZWVscyBPS1xuLy8gKiBwcm9jZXNzIHRhcHNcbi8vICAgKiBmaXJzdCB0b3VjaCBzdGFydHMgYWN0aXZlIHRhcFxuLy8gICAqIGFsbCBzdWJzZXF1ZW50IHRvdWNoZXMgYWRkZWQgdG8gdGFwXG4vLyAgICogdGFwIGFjdGl2ZSB1bnRpbCBmaXJzdCB0b3VjaCBlbmRcbi8vICAgKiB0YXAgZmlyZXMgd2hlbiBvbiBsYXN0IHRvdWNoIGVuZCAob3IgdG91Y2ggY29udmVydGVkIHRvIHBhbiksIHVubGVzcyBubyB0YXBzIHJlbWFpbiAoYWxsIGNvbnZlcnRlZCB0byBwYW4pXG4vLyAgICogbmV3IGFjdGl2ZSB0YXAgY2FuIHN0YXJ0IHdoaWxlIG9sZCBvbmUgaXMgcnVubmluZyBidXQgbm9sb25nZXIgYWN0aXZlXG4vLyAqIGFsbCBwYW5zIGdldCBwdXQgaW50byBhIHNpbmdsZSBwYW4gdHJhY2tlclxuXG50eXBlIEFjdGl2ZVRhcCA9IHtcbiAgICBhY3RpdmU6IFNldDxudW1iZXI+O1xuICAgIHBvc2l0aW9uczogTWFwPG51bWJlciwge1xuICAgICAgICBjdXJyOiBQb2ludDJELFxuICAgICAgICBzdGFydDogUG9pbnQyRCxcbiAgICB9Pjtcbn07XG5cbnR5cGUgQWN0aXZlUGFuID0gTWFwPG51bWJlciwge1xuICAgIGN1cnI6IFBvaW50MkQsXG4gICAgcHJldjogUG9pbnQyRCxcbiAgICBzdGFydDogUG9pbnQyRCxcbn0+O1xuXG5leHBvcnQgY2xhc3MgR2VzdHVyZXMgaW1wbGVtZW50cyBUb3VjaEhhbmRsZXIge1xuICAgIHByaXZhdGUgaDogR2VzdHVyZUhhbmRsZXI7XG4gICAgcHJpdmF0ZSBhZGRUYXA6IEFjdGl2ZVRhcCB8IG51bGw7XG4gICAgcHJpdmF0ZSB0YXBzOiBNYXA8bnVtYmVyLCBBY3RpdmVUYXA+O1xuICAgIHByaXZhdGUgcGFuOiBBY3RpdmVQYW47XG5cbiAgICBwcml2YXRlIGVuZFRhcCh0YXA6IEFjdGl2ZVRhcCwgaWQ6IG51bWJlciwgcGFubmluZzogYm9vbGVhbikge1xuICAgICAgICB0aGlzLnRhcHMuZGVsZXRlKGlkKTtcbiAgICAgICAgdGFwLmFjdGl2ZS5kZWxldGUoaWQpO1xuICAgICAgICBpZiAocGFubmluZykge1xuICAgICAgICAgICAgdGFwLnBvc2l0aW9ucy5kZWxldGUoaWQpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmFkZFRhcCA9PT0gdGFwKSB7XG4gICAgICAgICAgICB0aGlzLmFkZFRhcCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRhcC5hY3RpdmUuc2l6ZSA9PT0gMCAmJiB0YXAucG9zaXRpb25zLnNpemUgPiAwKSB7XG4gICAgICAgICAgICBjb25zdCBwb3NpdGlvbnMgPSBbXTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgcCBvZiB0YXAucG9zaXRpb25zLnZhbHVlcygpKSB7XG4gICAgICAgICAgICAgICAgcG9zaXRpb25zLnB1c2gocC5zdGFydCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmgudGFwKHBvc2l0aW9ucyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdHJ1Y3RvcihoOiBHZXN0dXJlSGFuZGxlcikge1xuICAgICAgICB0aGlzLmggPSBoO1xuICAgICAgICB0aGlzLmFkZFRhcCA9IG51bGw7XG4gICAgICAgIHRoaXMudGFwcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5wYW4gPSBuZXcgTWFwKCk7XG4gICAgfVxuXG4gICAgc3RhcnQodDogVG91Y2gpIHtcbiAgICAgICAgaWYgKHRoaXMudGFwcy5oYXModC5pZGVudGlmaWVyKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVG91Y2ggc3RhcnQgb24gYWxyZWFkeSB0cmFja2VkIHRhcFwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5hZGRUYXAgPT09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIElmIG5vIHRhcHMgYXJlIGFjdGl2ZSwgc2V0IHVwIGEgdGFwIHRvIGFkZCBhIHRvdWNoIHRvLlxuICAgICAgICAgICAgdGhpcy5hZGRUYXAgPSB7XG4gICAgICAgICAgICAgICAgYWN0aXZlOiBuZXcgU2V0KCksXG4gICAgICAgICAgICAgICAgcG9zaXRpb25zOiBuZXcgTWFwKCksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYWRkVGFwLmFjdGl2ZS5hZGQodC5pZGVudGlmaWVyKTtcbiAgICAgICAgY29uc3QgcG9zOiBQb2ludDJEID0gW3QuY2xpZW50WCwgdC5jbGllbnRZXTtcbiAgICAgICAgdGhpcy5hZGRUYXAucG9zaXRpb25zLnNldCh0LmlkZW50aWZpZXIsIHtcbiAgICAgICAgICAgIGN1cnI6IHBvcyxcbiAgICAgICAgICAgIHN0YXJ0OiBwb3MsXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnRhcHMuc2V0KHQuaWRlbnRpZmllciwgdGhpcy5hZGRUYXApO1xuICAgIH1cblxuICAgIG1vdmUodHM6IFRvdWNoTGlzdCkge1xuICAgICAgICBsZXQgcGFuTW92ZWQgPSBmYWxzZTtcbiAgICAgICAgZm9yIChjb25zdCB0IG9mIHRzKSB7XG4gICAgICAgICAgICBjb25zdCB0YXAgPSB0aGlzLnRhcHMuZ2V0KHQuaWRlbnRpZmllcik7XG4gICAgICAgICAgICBpZiAodGFwICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwb3MgPSB0YXAucG9zaXRpb25zLmdldCh0LmlkZW50aWZpZXIpO1xuICAgICAgICAgICAgICAgIGlmIChwb3MgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUb3VjaCBpbiB0YXBzLCBidXQgbm90IHBvc2l0aW9uc1wiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcG9zLmN1cnIgPSBbdC5jbGllbnRYLCB0LmNsaWVudFldO1xuICAgICAgICAgICAgICAgIGlmICgxNiA8PSBwb2ludERpc3RhbmNlKHBvcy5jdXJyLCBwb3Muc3RhcnQpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRhcCBoYXMgbW92ZWQgZW5vdWdoIHRvIGJlIGEgcGFuIGluc3RlYWQuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW5kVGFwKHRhcCwgdC5pZGVudGlmaWVyLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wYW4uc2V0KHQuaWRlbnRpZmllciwge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycjogcG9zLmN1cnIsXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmV2OiBwb3Muc3RhcnQsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydDogcG9zLnN0YXJ0LFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgcGFuTW92ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcG9zID0gdGhpcy5wYW4uZ2V0KHQuaWRlbnRpZmllcik7XG4gICAgICAgICAgICAgICAgaWYgKHBvcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRvdWNoIG5vdCBpbiB0YXBzIG9yIHBhbnNcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHBvcy5wcmV2ID0gcG9zLmN1cnI7XG4gICAgICAgICAgICAgICAgcG9zLmN1cnIgPSBbdC5jbGllbnRYLCB0LmNsaWVudFldO1xuICAgICAgICAgICAgICAgIGlmICghcG9pbnRFcXVhbHMocG9zLnByZXYsIHBvcy5jdXJyKSkge1xuICAgICAgICAgICAgICAgICAgICBwYW5Nb3ZlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChwYW5Nb3ZlZCkge1xuICAgICAgICAgICAgY29uc3QgcG9zaXRpb25zID0gW107XG4gICAgICAgICAgICAvLyBOQjogcGFuIGlzIGluIGluc2VydGlvbiBvcmRlciwgc28gcG9zaXRpb25zIHdpbGwgYmUgc2VudCBmcm9tIG9sZGVzdCB0b3VjaCB0byBuZXdlc3QuXG4gICAgICAgICAgICBmb3IgKGNvbnN0IHAgb2YgdGhpcy5wYW4udmFsdWVzKCkpIHtcbiAgICAgICAgICAgICAgICBwb3NpdGlvbnMucHVzaChwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuaC5wYW4ocG9zaXRpb25zKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGVuZChpZDogbnVtYmVyKSB7XG4gICAgICAgIGNvbnN0IHRhcCA9IHRoaXMudGFwcy5nZXQoaWQpO1xuICAgICAgICBpZiAodGFwICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZW5kVGFwKHRhcCwgaWQsIGZhbHNlKTtcbiAgICAgICAgfSBlbHNlIGlmICghdGhpcy5wYW4uZGVsZXRlKGlkKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVG91Y2ggZW5kIHRoYXQgd2FzIG5vdCBhIHRhcCBvciBhIHBhblwiKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ2xpcFBvc2l0aW9uIHtcbiAgICAocG9zOiBWaWV3cG9ydFBvc2l0aW9uKTogVmlld3BvcnRQb3NpdGlvbjtcbn1cblxuLy8gVE9ETzogcHV0IHRoaXMgaW4gaXQncyBvd24gY2xhc3Ncbm5ldyBUb3VjaERlbXV4KGMsIG5ldyBHZXN0dXJlcyh7XG4gICAgdGFwOiAodDogVGFwKSA9PiB7XG4gICAgICAgIGNvbnN0IHMydyA9IHZwLnNjcmVlbjJ3b3JsZCgpO1xuICAgICAgICBjb25zb2xlLmxvZyhcInRhcDogXCIsIHQsIFwiIHdvcmxkOiBcIiwgdHJhbnNmb3JtUG9pbnQoczJ3LCB0WzBdKSk7XG4gICAgfSxcbiAgICBwYW46IChwczogUGFuKSA9PiB7XG4gICAgICAgIGNvbnN0IHBvcyA9IHZwLnBvc2l0aW9uKCk7XG4gICAgICAgIGNvbnN0IHMydyA9IHZwLnNjcmVlbjJ3b3JsZCgpO1xuICAgICAgICBpZiAocHMubGVuZ3RoID09IDEpIHtcbiAgICAgICAgICAgIGNvbnN0IHAgPSBwc1twcy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIGNvbnN0IGN1cnIgPSB0cmFuc2Zvcm1Qb2ludChzMncsIHAuY3Vycik7XG4gICAgICAgICAgICBjb25zdCBwcmV2ID0gdHJhbnNmb3JtUG9pbnQoczJ3LCBwLnByZXYpO1xuICAgICAgICAgICAgdnAuc2V0UG9zaXRpb24oe1xuICAgICAgICAgICAgICAgIHBvczogcG9pbnRBZGQocG9zLnBvcywgcG9pbnRTdWIocHJldiwgY3VycikpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSBpZiAocHMubGVuZ3RoID49IDIpIHtcbiAgICAgICAgICAgIGNvbnN0IHAxID0gcHNbcHMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICBjb25zdCBwMiA9IHBzW3BzLmxlbmd0aCAtIDJdO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBjb25zdCB3cDFwcmV2ID0gdHJhbnNmb3JtUG9pbnQoczJ3LCBwMS5wcmV2KTtcbiAgICAgICAgICAgIGNvbnN0IGN1cnJhID0gcG9pbnRBbmdsZShwb2ludFN1YihwMi5jdXJyLCBwMS5jdXJyKSk7XG4gICAgICAgICAgICBjb25zdCBwcmV2YSA9IHBvaW50QW5nbGUocG9pbnRTdWIocDIucHJldiwgcDEucHJldikpO1xuICAgICAgICAgICAgY29uc3QgY3VycmwgPSBwb2ludERpc3RhbmNlKHAxLmN1cnIsIHAyLmN1cnIpO1xuICAgICAgICAgICAgY29uc3QgcHJldmwgPSBwb2ludERpc3RhbmNlKHAxLnByZXYsIHAyLnByZXYpO1xuICAgICAgICAgICAgY29uc3Qgd3AxY3VyciA9IHRyYW5zZm9ybVBvaW50KHMydywgcDEuY3Vycik7XG4gICAgICAgICAgICBsZXQgdCA9IHRyYW5zZm9ybVRyYW5zbGF0ZUNyZWF0ZSgtd3AxY3VyclswXSwgLXdwMWN1cnJbMV0pO1xuICAgICAgICAgICAgdCA9IHRyYW5zZm9ybVNjYWxlKHQsIHByZXZsIC8gY3VycmwpO1xuICAgICAgICAgICAgdCA9IHRyYW5zZm9ybVJvdGF0ZSh0LCBwcmV2YSAtIGN1cnJhKTtcbiAgICAgICAgICAgIHQgPSB0cmFuc2Zvcm1UcmFuc2xhdGUodCwgd3AxcHJldlswXSwgd3AxcHJldlsxXSk7XG4gICAgICAgICAgICAvLyBUT0RPOiB3aHkgZG9lcyB0aGlzIHdvcms/IElzbid0IGl0IGJhY2t3YXJkcz9cblxuICAgICAgICAgICAgdnAuc2V0UG9zaXRpb24oe1xuICAgICAgICAgICAgICAgIHBvczogdHJhbnNmb3JtUG9pbnQodCwgcG9zLnBvcyksXG4gICAgICAgICAgICAgICAgc2NhbGU6IHBvcy5zY2FsZSAqIGN1cnJsIC8gcHJldmwsXG4gICAgICAgICAgICAgICAgcm90YXRlOiBwb3Mucm90YXRlIC0gcHJldmEgKyBjdXJyYSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSxcbn0pKTtcblxuY29uc29sZS5sb2coXCJzdHVmZiBsb2FkZWRcIik7XG4iXX0=